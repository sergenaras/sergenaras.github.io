# Fork BombasÄ±

Created by: Sergen
Created time: December 6, 2022 12:09 AM
Last edited by: Sergen
Last edited time: April 17, 2023 10:50 AM
Status: Done
Tags: linux 101

Fork bombasÄ±, Unix tabanlÄ± sistemlere karÅŸÄ± yapÄ±lan bir tÃ¼rk denial-of-service (dos) saldÄ±rÄ±sÄ±dÄ±r. Komut `:(){ :|:& };:` ÅŸu ÅŸekilde yazÄ±lÄ±r ve gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere pek bir ÅŸey yapmaz. Ancak yaptÄ±ÄŸÄ± iÃ§in sÃ¼rekli kendisini Ã§aÄŸÄ±rmak iÅŸletim sistemi Ã¼zerinde yeni yeni processâ€™ler oluÅŸturmaktadÄ±r. Bu da iÅŸletim sistemindeki process limitlerine ulaÅŸmak ve onu doldurduktan sonra hiÃ§bir ÅŸeyi Ã§alÄ±ÅŸamayacak duruma getirmeyi hedeflemektedir. Bir kere bu bombanÄ±n Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± makine yeniden baÅŸlatÄ±lmadan dÃ¼zelme durumu bulunmamaktadÄ±r.

Linux process limitleri `/etc/security/limits.conf` dosyasÄ±ndan gerÃ§ekleÅŸtirilebilir.

## Fork BombasÄ±nÄ± Anlamak

`:() - :` isminde bir fonksiyon oluÅŸturulur ve argÃ¼man kabul etmez.

Åu Ã¶rnek Ã¼zerinden fonksiyon daha aÃ§Ä±k bir ÅŸekilde gÃ¶rÃ¼lebilir.

```bash
foo(){
 arg1=$1
 arg2=$2
 echo 'Bar..'
 #do_something on $arg argument
}
```

Fork bombasÄ± yukarÄ±daki ÅŸekilde yazÄ±lmasÄ± gerekirse;

```bash
:(){
 :|:&
};:
```

`:|:` - Bu sayede aynÄ± fonksiyonu kendi iÃ§erisinde tekrar Ã§aÄŸÄ±rÄ±yoruz ve pipe sonrasÄ±nda tekrar Ã§aÄŸÄ±rÄ±yoruz. Bu sayede aynÄ± iÅŸlemi iki defa daha yapacak birer bomba Ã§aÄŸÄ±rmÄ±ÅŸ olduk ve onlar da aynÄ± Ã§aÄŸÄ±rma iÅŸlemlerini gerÃ§ekleÅŸtirecekler..

`&` - ProgramÄ± arka plana atar. Bu sayede sistem kaynaklarÄ±nÄ± tÃ¼ketene kadar sÃ¼reÃ§ Ã¶ldÃ¼rÃ¼lemez.

`;` - ProgramÄ±n tamamlanmasÄ± sonrasÄ±nda onu sonlandÄ±rÄ±r.

`:` - HÄ±z aÃ§Ä±sÄ±ndan : kullanÄ±lÄ±yor olabilir ancak burada : yerine ne yazdÄ±ÄŸÄ±mÄ±z Ã§ok da Ã¶nemli deÄŸildir. Daha okunabilir bir kod iÃ§in;

```bash
bomb() { 
 bomb | bomb &
}; bomb
```

## Fork BombasÄ±nÄ± Ã–nlemek

Sistemde Ã§alÄ±ÅŸabilecek maksimum process sayÄ±sÄ±nÄ± bulmak iÃ§in aÅŸaÄŸÄ±daki komutu yÃ¼rÃ¼tebilirsiniz.

```bash
$ ulimit -u
31475
```

Yahut `ulimit -a` komutu ile tÃ¼m limitlere gÃ¶z atÄ±labilir.

Bizim bu komutu yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mÃ¼z kullanÄ±cÄ± ile oluÅŸturabileceÄŸimiz process sayÄ±sÄ± 31475â€™tir. Sistemi fork bombasÄ±ndan koruyabilmek iÃ§in bunu daha dÃ¼ÅŸÃ¼k bir sayÄ±ya Ã§ekmeniz gerekmektedir. Bunu aÅŸaÄŸÄ±daki ÅŸekilde yapabilirsiniz.

```bash
$ ulimit -S -u 5000
$ ulimit -u
5000
```

Åimdi test iÃ§in tekrar fork bombasÄ±nÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m.

ve sistem yine Ã§Ã¶ktÃ¼.. yeniden baÅŸlatÄ±p iÃ§erisine girdiÄŸimde ulimit deÄŸerinin eski haline geldiÄŸini gÃ¶rdÃ¼m. Tekrar 5000 yapÄ±p bombayÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m.

```bash
$ :(){  :|:& };:
...
-bash: fork: retry: Resource temporarily unavailable
-bash: fork: Resource temporarily unavailable

[1]+  Done                    : | :
```

TÃ¼m bu iÅŸlemleri yaparken farklÄ± bir ssh Ã¼zerinden aÅŸaÄŸÄ±daki komutla aktif process sayÄ±sÄ±nÄ± gÃ¶zlemledim.

```bash
$ pgrep -wcu $USER
5000
$ pgrep -wcu $USER
4908
$ pgrep -wcu $USER
3032
$ pgrep -wcu $USER
15
```

2 3 saniye aralÄ±klarla Ã§alÄ±ÅŸtÄ±rÄ±lan komutlarsa komutu yÃ¼rÃ¼tÃ¼r yÃ¼rÃ¼tmez process sayÄ±sÄ±nÄ±n 5000â€™e vurduÄŸu ve sonrasÄ±nda programlar sonlandÄ±rÄ±ldÄ±kÃ§a azaldÄ±klarÄ± gÃ¶rÃ¼lebilir.

Daha Ã¶nce yapÄ±lan testte sorun yaÅŸamamÄ±zÄ±n nedeni **root** kullanÄ±cÄ±sÄ± ile iÅŸlem yapmamÄ±zdÄ±. root kullanÄ±cÄ±sÄ± bu kÄ±sÄ±tlamalara dahil deÄŸildir.

<aside>
ğŸ’¡ 5000 Ã§ok gibi gÃ¶rÃ¼nse de process limit iÃ§in az bir sayÄ±dÄ±r. Ã–zellikle veritabanÄ± gibi iÅŸlemlerin yoÄŸunluklu olabileceÄŸi sunucularda bu iÅŸlemi yapmadan Ã¶nce process sayÄ±larÄ±nÄ±n ne aralÄ±kta dolandÄ±klarÄ± izlenmesi gerekebilir.

</aside>